{"version":3,"sources":["Store.ts","AddTrack.tsx","Track.tsx","TrackSettings.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["avg","a","b","aw","bw","convertToTrackPoint","data","latitude","longitude","heartrate","elevation","timestamp","dayjs","valueOf","parseGPX","id","name","parser","xml2js","Parser","Promise","res","rej","parseString","err","xml","parseTrack","gpx","trk","map","positions","startTime","Math","min","position","endTime","max","relativePositions","relativeTime","timeOffset","store","getCurrentPoint","track","tracks","find","Error","before","filter","point","currentTime","reverse","after","abs","persist","tracksById","JSON","stringify","window","localStorage","setItem","getTrackColor","index","niceColors","length","str","hash","i","charCodeAt","colour","toString","substr","stringToColour","getColor","pair","Infinity","parse","getItem","console","log","this","Object","values","observable","computed","action","uuid","observe","setInterval","autoIncrement","SPEED","maxTime","observer","useState","isOpen","setIsOpen","useDropzone","acceptedFiles","getRootProps","getInputProps","Set","deletedFiles","setDeletedFiles","deleteFile","file","set","newSet","add","useEffect","forEach","Modal","trigger","Button","primary","content","onClick","open","onClose","Header","Content","has","Segment","key","style","display","justifyContent","negative","icon","Actions","text","split","addTrack","color","currentPosition","Polyline","trackpoint","CircleMarker","center","radius","borderTop","List","horizontal","Item","Input","label","labelPosition","type","val","onChange","e","target","value","removeTrack","Icon","className","alignItems","top","right","zIndex","maxHeight","overflow","bottom","left","basic","flexGrow","settings","step","Map","zoom","TileLayer","attribution","url","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"0hBAwCMA,EAAM,SAACC,EAAWC,EAAWC,EAAYC,GAAnC,OACH,IAAPD,EAAWD,GAAKD,EAAIE,EAAKD,EAAIE,IAAOD,EAAKC,IAErCC,EAAsB,SAACC,GAAD,MACzB,CACCC,UAAWD,EAAKC,SAChBC,WAAYF,EAAKE,UACjBC,WAAYH,EAAKG,UACjBC,WAAYJ,EAAKI,UACjBC,UAAWC,IAAMN,EAAKK,WAAWE,YAG/BC,EAAQ,uCAAG,WAAOR,EAAcS,EAAYC,GAAjC,uBAAAf,EAAA,6DACTgB,EAAS,IAAIC,IAAOC,OADX,SAEU,IAAIC,SAAQ,SAACC,EAAKC,GAAN,OACnCL,EAAOM,YAAYjB,GAAM,SAACkB,EAAUC,GAC9BD,EACFF,EAAIE,GAEJH,EAAIK,IAAWD,EAAIE,IAAIC,KAAKC,IAAIxB,UAPvB,cAETyB,EAFS,OAWTC,EAAYC,KAAKC,IAAL,MAAAD,KAAI,YACjBF,EAAUD,KAAI,SAACK,GAAD,OAAcA,EAASvB,eAEpCwB,EAAUH,KAAKI,IAAL,MAAAJ,KAAI,YAAQF,EAAUD,KAAI,SAACK,GAAD,OAAcA,EAASvB,eAC3D0B,EAAoBP,EAAUD,KAClC,SAACK,GAAD,sBAEOA,EAFP,CAGII,aAAcJ,EAASvB,UAAYoB,OAnB1B,kBAuBR,CACLf,OACAD,KACAe,UAAWO,EACXN,YACAI,UACAI,WAAY,IA7BC,2CAAH,0DA0HRC,EAAQ,I,aAhFZ,aAAe,IAAD,OACZ,GADY,0NA8BdC,gBAAkB,SAAC1B,GACjB,IAAM2B,EAAQ,EAAKC,OAAOC,MAAK,qBAAG7B,KAAsBA,KACxD,IAAK2B,EAAO,MAAM,IAAIG,MAAM,gBAE5B,IAAMC,EAASJ,EAAMZ,UAClBiB,QACC,SAACC,GAAD,OAAWA,EAAMV,aAAeI,EAAMH,YAAc,EAAKU,eAE1DC,UAAU,GACPC,EAAQT,EAAMZ,UAAUiB,QAC5B,SAACC,GAAD,OAAWA,EAAMV,aAAeI,EAAMH,YAAc,EAAKU,eACzD,GAEF,OAAKH,GAAWK,EAET,CACLnD,EACE8C,EAAOvC,SACP4C,EAAM5C,SACNyB,KAAKoB,IAAID,EAAMb,aAAe,EAAKW,aACnCjB,KAAKoB,IAAIN,EAAOR,aAAe,EAAKW,cAEtCjD,EACE8C,EAAOtC,UACP2C,EAAM3C,UACNwB,KAAKoB,IAAID,EAAMb,aAAe,EAAKW,aACnCjB,KAAKoB,IAAIN,EAAOR,aAAe,EAAKW,eAbV,MA3ClB,KA6DdI,QAAU,WACR,IAAMC,EAAaC,KAAKC,UAAUhB,EAAMc,YAClCL,EAAcM,KAAKC,UAAUhB,EAAMS,aAEzCQ,OAAOC,aAAaC,QAAQ,aAAcL,GAC1CG,OAAOC,aAAaC,QAAQ,cAAeV,GAC3CQ,OAAOC,aAAaC,QAAQ,eAAgBJ,KAAKC,UA3JhC,KAwFL,KAsEdI,cAAgB,SAAC7C,GACf,OAhJa,SAACA,EAAY8C,GAC5B,IAAMC,EAAa,CACjB,UACA,UACA,UACA,UACA,UACA,UACA,UACA,WAGF,OAAID,EAAQC,EAAWC,OACdD,EAAWD,GA1BC,SAACG,GAEtB,IADA,IAAIC,EAAO,EACFC,EAAI,EAAGA,EAAIF,EAAID,OAAQG,IAC9BD,EAAOD,EAAIG,WAAWD,KAAOD,GAAQ,GAAKA,GAG5C,IADA,IAAIG,EAAS,IACJF,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAE1BE,IAAW,MADEH,GAAa,EAAJC,EAAU,KACRG,SAAS,KAAKC,QAAQ,GAEhD,OAAOF,EAkBEG,CAAexD,GAiIfyD,CACLzD,GACC,EAAK4B,OACHd,KAAI,SAACa,EAAOwB,GAAR,MAAc,CAACxB,EAAM3B,GAAImD,MAC7BtB,MAAK,SAAC6B,GAAD,OAAUA,EAAK,KAAO1D,MAAO,CAAC,GAAI2D,MAAW,KAnKtC,IA0FfnB,KAAKoB,MAAMlB,OAAOC,aAAakB,QAAQ,iBAAmB,MAE1D,CACAC,QAAQC,IAAI,aAEZ,IAAMxB,EAAaG,OAAOC,aAAakB,QAAQ,cAC3CtB,IAAYyB,KAAKzB,WAAaC,KAAKoB,MAAMrB,IAE7C,IAAML,EAAcQ,OAAOC,aAAakB,QAAQ,eAC5C3B,IAAa8B,KAAK9B,YAAcM,KAAKoB,MAAM1B,K,mDAdjD,OAAO+B,OAAOC,OAAOF,KAAKzB,gB,6CAmB1B,OAAOtB,KAAKI,IAAL,MAAAJ,KAAI,YACN+C,KAAKpC,OAAOd,KAAI,SAACa,GAAD,OAAWA,EAAMP,QAAUO,EAAMX,mB,6CAzBvDmD,K,wEAAkD,M,yCAClDA,K,yEAAyB,K,2CACzBA,K,yEAA2B,K,kCAE3BC,K,sGAmBAA,K,0GAMAC,K,2HAAkB,WAAO1C,EAAe1B,GAAtB,eAAAf,EAAA,6DACXc,EAAKsE,cADM,SAEWvE,EAAS4B,EAAO3B,EAAIC,GAF/B,OAEjB,EAAKsC,WAAWvC,GAFC,kD,oGAKlBqE,K,oFAAqB,SAACrE,UACd,EAAKuC,WAAWvC,O,GAuD1B0C,OAAeJ,QAAUb,EAAMa,QAEhCiC,YAAQ9C,EAAMc,YAAY,WACxBd,EAAMa,aAKRkC,aAAY,WACN/C,EAAMgD,gBACRhD,EAAMS,YAAcjB,KAAKC,IACvBO,EAAMS,YAAewC,IACrBjD,EAAMkD,YAGT,KAEYlD,QC1HAmD,eAjEE,WAAO,IAAD,EACOC,oBAAS,GADhB,mBACdC,EADc,KACNC,EADM,OAEkCC,cAA/CC,EAFa,EAEbA,cAAeC,EAFF,EAEEA,aAAcC,EAFhB,EAEgBA,cAFhB,EAGmBN,mBAAS,IAAIO,KAHhC,mBAGdC,EAHc,KAGAC,EAHA,KAKfC,EAAa,SAACC,GAAD,OACjBF,GAAgB,SAACG,GACf,IAAMC,EAAS,IAAIN,IAAIK,GAEvB,OADAC,EAAOC,IAAIH,GACJE,MAqBX,OALAE,qBAAU,WACRX,EAAcY,QAAQN,KAErB,CAACT,IAGF,kBAACgB,EAAA,EAAD,CACEC,QACE,kBAACC,EAAA,EAAD,CAAQC,SAAO,EAACC,QAAQ,aAAaC,QAAS,kBAAMpB,GAAU,MAEhEqB,KAAMtB,EACNuB,QAAS,kBAAMtB,GAAU,KAEzB,kBAACe,EAAA,EAAMQ,OAAP,kBACA,kBAACR,EAAA,EAAMS,QAAP,KACGtB,EACEjD,QAAO,SAACwD,GAAD,OAAWH,EAAamB,IAAIhB,MACnC1E,KAAI,SAAC0E,GAAD,OACH,kBAACiB,EAAA,EAAD,CACEC,IAAKlB,EAAKvF,KACV0G,MAAO,CAAEC,QAAS,OAAQC,eAAgB,kBAEzCrB,EAAKvF,KACN,kBAAC+F,EAAA,EAAD,CAAQc,UAAQ,EAACC,KAAK,QAAQZ,QAAS,kBAAMZ,EAAWC,UAG9D,wBAASN,IACP,kBAACuB,EAAA,EAAD,KACE,0BAAWtB,KACX,6FAIN,kBAACW,EAAA,EAAMkB,QAAP,KACE,kBAAChB,EAAA,EAAD,CAAQC,SAAO,EAACC,QAAQ,sBAAsBC,QA/C/B,WACnBlB,EACGjD,QAAO,SAACwD,GAAD,OAAWH,EAAamB,IAAIhB,MACnCK,QAFH,+BAAA3G,EAAA,MAGI,WAAOsG,GAAP,SAAAtG,EAAA,kEACQuC,EADR,SAEW+D,EAAayB,OAFxB,+BAGIzB,EAAKvF,KAAKiH,MAAM,KAAK,GAHzB,cACcC,SADd,wGAHJ,uDASApC,GAAU,W,2BCECH,eApBD,SAAC,GAA6B,IAA3BjD,EAA0B,EAA1BA,MACTyF,GADmC,EAAnBtE,MACRrB,EAAMoB,cAAclB,EAAM3B,KAClCqH,EAAkB5F,EAAMC,gBAAgBC,EAAM3B,IAEpD,OACE,oCACE,kBAACsH,EAAA,EAAD,CACEF,MAAOA,EACPrG,UAAWY,EAAMZ,UAAUD,KACzB,SAACyG,GAAD,MACE,CAACA,EAAW/H,SAAU+H,EAAW9H,gBAGtC4H,GACC,kBAACG,EAAA,EAAD,CAAcC,OAAQJ,EAAiBD,MAAOA,EAAOM,OAAQ,S,0BCqBtD9C,eApCO,SAAC,GAAsB,IAApBjD,EAAmB,EAAnBA,MACjByF,EAAQ3F,EAAMoB,cAAclB,EAAM3B,IAExC,OACE,kBAACyG,EAAA,EAAD,CACEE,MAAO,CACLgB,UAAU,aAAD,OAAeP,GACxBR,QAAS,OACTC,eAAgB,aAGlB,kBAACe,EAAA,EAAD,CAAMC,YAAU,GACd,kBAACD,EAAA,EAAKE,KAAN,KACE,2BAAInG,EAAM1B,OAEZ,kBAAC2H,EAAA,EAAKE,KAAN,KACE,kBAACC,EAAA,EAAD,CACEC,MAAM,oBACNC,cAAc,cACdC,KAAK,SACLC,IAAG,UAAK1G,EAAMc,WAAWZ,EAAM3B,IAAIwB,WAAa,KAChD4G,SAAU,SAACC,GACT5G,EAAMc,WAAWZ,EAAM3B,IAAIwB,WAA+B,KAAjB6G,EAAEC,OAAOC,UAIxD,kBAACX,EAAA,EAAKE,KAAN,KACE,kBAAC9B,EAAA,EAAD,CAAQe,MAAI,EAACD,UAAQ,EAACX,QAAS,kBAAM1E,EAAM+G,YAAY7G,EAAM3B,MAC3D,kBAACyI,EAAA,EAAD,CAAMxI,KAAK,iBCmDR2E,mBA7Ef,WACE,OACE,yBACE8D,UAAU,MACV/B,MAAO,CACLC,QAAS,OACTC,eAAgB,SAChB8B,WAAY,WAGd,yBACEhC,MAAO,CACLxF,SAAU,WACVyH,IAAK,EACLC,MAAO,EACPC,OAAQ,IACRC,UAAW,sBACXC,SAAU,SAGZ,kBAACvC,EAAA,EAAD,KACGhF,EAAMG,OAAOd,KAAI,SAACa,GAAD,OAChB,kBAAC,EAAD,CAAe+E,IAAK/E,EAAM3B,GAAI2B,MAAOA,OAEvC,kBAAC,EAAD,QAGHF,EAAMG,OAAOoB,QACZ,yBACE2D,MAAO,CACLxF,SAAU,WACV8H,OAAQ,EACRJ,MAAO,EACPK,KAAM,EACNJ,OAAQ,MAGV,kBAACrC,EAAA,EAAD,CAASE,MAAO,CAAEC,QAAS,OAAQ+B,WAAY,WAC7C,kBAAC3C,EAAA,EAAD,CACEG,QAAS,WACP1E,EAAMgD,eAAiBhD,EAAMgD,eAE/B0E,OAAK,GAEJ1H,EAAMgD,cAAgB,OAAS,QAElC,yBAAKkC,MAAO,CAAEyC,SAAU,IACtB,kBAAC,SAAD,CACEb,MAAO9G,EAAMS,YACbmH,SAAU,CACRnI,IAAK,EACLG,IAAKI,EAAMkD,QACX2E,KAAM,EACNlB,SAAU,SAACG,GACLtH,KAAKoB,IAAIkG,EAAQ9G,EAAMS,aAAe,MACxCT,EAAMgD,eAAgB,GACxBhD,EAAMS,YAAcqG,SAQlC,kBAACgB,EAAA,EAAD,CAAK9B,OAAQ,CAAC,kBAAmB,oBAAqB+B,KAAM,IAC1D,kBAACC,EAAA,EAAD,CACEC,YAAY,0EACZC,IAAI,uDAELlI,EAAMG,OAAOd,KAAI,SAACa,EAAOwB,GAAR,OAChB,kBAAC,EAAD,CAAOxB,MAAOA,EAAOmB,MAAOK,YCrElByG,QACW,cAA7BlH,OAAOmH,SAASC,UAEe,UAA7BpH,OAAOmH,SAASC,UAEhBpH,OAAOmH,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,SDiIpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACL9G,QAAQ8G,MAAMA,EAAMC,c","file":"static/js/main.712aee37.chunk.js","sourcesContent":["import { observe, observable, action, computed } from \"mobx\";\nimport { v4 as uuid } from \"uuid\";\nimport parseTrack from \"parse-gpx/src/parseTrack\";\nimport xml2js from \"xml2js\";\nimport dayjs from \"dayjs\";\n\nconst storeVersion = 2;\n\nconst stringToColour = (str: string) => {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    hash = str.charCodeAt(i) + ((hash << 5) - hash);\n  }\n  let colour = \"#\";\n  for (let i = 0; i < 3; i++) {\n    let value = (hash >> (i * 8)) & 0xff;\n    colour += (\"00\" + value.toString(16)).substr(-2);\n  }\n  return colour;\n};\n\nconst getColor = (id: string, index: number) => {\n  const niceColors = [\n    \"#CC0000\",\n    \"#FF8000\",\n    \"#FFFF00\",\n    \"#00FF00\",\n    \"#0080FF\",\n    \"#7F00FF\",\n    \"#FF00FF\",\n    \"#663300\",\n  ];\n\n  if (index < niceColors.length) {\n    return niceColors[index];\n  } else {\n    return stringToColour(id);\n  }\n};\n\nconst avg = (a: number, b: number, aw: number, bw: number) =>\n  aw === 0 ? b : (a * aw + b * bw) / (aw + bw);\n\nconst convertToTrackPoint = (data: any) =>\n  ({\n    latitude: +data.latitude,\n    longitude: +data.longitude,\n    heartrate: +data.heartrate,\n    elevation: +data.elevation,\n    timestamp: dayjs(data.timestamp).valueOf(),\n  } as Partial<TrackPoint>);\n\nconst parseGPX = async (data: string, id: string, name: string) => {\n  const parser = new xml2js.Parser();\n  const positions = (await new Promise((res, rej) =>\n    parser.parseString(data, (err: any, xml: any) => {\n      if (err) {\n        rej(err);\n      } else {\n        res(parseTrack(xml.gpx.trk).map(convertToTrackPoint));\n      }\n    })\n  )) as TrackPoint[];\n  const startTime = Math.min(\n    ...positions.map((position) => position.timestamp)\n  );\n  const endTime = Math.max(...positions.map((position) => position.timestamp));\n  const relativePositions = positions.map(\n    (position) =>\n      ({\n        ...position,\n        relativeTime: position.timestamp - startTime,\n      } as TrackPoint)\n  );\n\n  return {\n    name,\n    id,\n    positions: relativePositions,\n    startTime,\n    endTime,\n    timeOffset: 0,\n  };\n};\n\nclass Store {\n  @observable tracksById: { [key: string]: Track } = {};\n  @observable currentTime = 0;\n  @observable autoIncrement = false;\n\n  @computed get tracks() {\n    return Object.values(this.tracksById);\n  }\n\n  constructor() {\n    if (\n      JSON.parse(window.localStorage.getItem(\"storeVersion\") || \"-1\") ===\n      storeVersion\n    ) {\n      console.log(\"restoring\");\n\n      const tracksById = window.localStorage.getItem(\"tracksById\");\n      if (tracksById) this.tracksById = JSON.parse(tracksById);\n\n      const currentTime = window.localStorage.getItem(\"currentTime\");\n      if (currentTime) this.currentTime = JSON.parse(currentTime);\n    }\n  }\n\n  @computed get maxTime() {\n    return Math.max(\n      ...this.tracks.map((track) => track.endTime - track.startTime)\n    );\n  }\n\n  @action addTrack = async (track: string, name: string) => {\n    const id = uuid();\n    this.tracksById[id] = await parseGPX(track, id, name);\n  };\n\n  @action removeTrack = (id: string) => {\n    delete this.tracksById[id];\n  };\n\n  getCurrentPoint = (id: string) => {\n    const track = this.tracks.find(({ id: _id }) => _id === id);\n    if (!track) throw new Error(\"id not found\");\n\n    const before = track.positions\n      .filter(\n        (point) => point.relativeTime + track.timeOffset <= this.currentTime\n      )\n      .reverse()[0];\n    const after = track.positions.filter(\n      (point) => point.relativeTime + track.timeOffset >= this.currentTime\n    )[0];\n\n    if (!before || !after) return null;\n\n    return [\n      avg(\n        before.latitude,\n        after.latitude,\n        Math.abs(after.relativeTime - this.currentTime),\n        Math.abs(before.relativeTime - this.currentTime)\n      ),\n      avg(\n        before.longitude,\n        after.longitude,\n        Math.abs(after.relativeTime - this.currentTime),\n        Math.abs(before.relativeTime - this.currentTime)\n      ),\n    ] as [number, number];\n  };\n\n  persist = () => {\n    const tracksById = JSON.stringify(store.tracksById);\n    const currentTime = JSON.stringify(store.currentTime);\n\n    window.localStorage.setItem(\"tracksById\", tracksById);\n    window.localStorage.setItem(\"currentTime\", currentTime);\n    window.localStorage.setItem(\"storeVersion\", JSON.stringify(storeVersion));\n  };\n\n  getTrackColor = (id: string) => {\n    return getColor(\n      id,\n      (this.tracks\n        .map((track, i) => [track.id, i] as [string, number])\n        .find((pair) => pair[0] === id) || [\"\", Infinity])[1]\n    );\n  };\n}\n\nconst store = new Store();\n\n(window as any).persist = store.persist;\n\nobserve(store.tracksById, () => {\n  store.persist();\n});\n\nconst SPEED = 60;\nconst FPS = 10;\nsetInterval(() => {\n  if (store.autoIncrement) {\n    store.currentTime = Math.min(\n      store.currentTime + (SPEED * 1000) / FPS,\n      store.maxTime\n    );\n  }\n}, 1000 / FPS);\n\nexport default store;\n","import React, { useState, useEffect } from \"react\";\nimport { observer } from \"mobx-react\";\nimport { useDropzone } from \"react-dropzone\";\nimport { Modal, Button, Segment } from \"semantic-ui-react\";\nimport store from \"./Store\";\n\nconst AddTrack = () => {\n  const [isOpen, setIsOpen] = useState(false);\n  const { acceptedFiles, getRootProps, getInputProps } = useDropzone();\n  const [deletedFiles, setDeletedFiles] = useState(new Set());\n\n  const deleteFile = (file: File) =>\n    setDeletedFiles((set) => {\n      const newSet = new Set(set);\n      newSet.add(file);\n      return newSet;\n    });\n\n  const handleSubmit = () => {\n    acceptedFiles\n      .filter((file) => !deletedFiles.has(file))\n      .forEach(\n        async (file) =>\n          await store.addTrack(\n            await (file as any).text(),\n            file.name.split(\".\")[0]\n          )\n      );\n    setIsOpen(false);\n  };\n\n  useEffect(() => {\n    acceptedFiles.forEach(deleteFile);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isOpen]);\n\n  return (\n    <Modal\n      trigger={\n        <Button primary content=\"Add Tracks\" onClick={() => setIsOpen(true)} />\n      }\n      open={isOpen}\n      onClose={() => setIsOpen(false)}\n    >\n      <Modal.Header>Add Track</Modal.Header>\n      <Modal.Content>\n        {acceptedFiles\n          .filter((file) => !deletedFiles.has(file))\n          .map((file) => (\n            <Segment\n              key={file.name}\n              style={{ display: \"flex\", justifyContent: \"space-between\" }}\n            >\n              {file.name}\n              <Button negative icon=\"trash\" onClick={() => deleteFile(file)} />\n            </Segment>\n          ))}\n        <div {...getRootProps()}>\n          <Segment>\n            <input {...getInputProps()} />\n            <p>+ Drag 'n' drop some files here, or click to select files +</p>\n          </Segment>\n        </div>\n      </Modal.Content>\n      <Modal.Actions>\n        <Button primary content=\"Add selected tracks\" onClick={handleSubmit} />\n      </Modal.Actions>\n    </Modal>\n  );\n};\n\nexport default observer(AddTrack);\n","import { observer } from \"mobx-react\";\nimport React from \"react\";\nimport { CircleMarker, Polyline } from \"react-leaflet\";\nimport store from \"./Store\";\n\ntype Props = {\n  track: Track;\n  index: number;\n};\n\nconst Track = ({ track, index }: Props) => {\n  const color = store.getTrackColor(track.id);\n  const currentPosition = store.getCurrentPoint(track.id);\n\n  return (\n    <>\n      <Polyline\n        color={color}\n        positions={track.positions.map(\n          (trackpoint) =>\n            [trackpoint.latitude, trackpoint.longitude] as [number, number]\n        )}\n      />\n      {currentPosition && (\n        <CircleMarker center={currentPosition} color={color} radius={10} />\n      )}\n    </>\n  );\n};\n\nexport default observer(Track);\n","import React from \"react\";\nimport { observer } from \"mobx-react\";\nimport { List, Button, Icon, Segment, Input } from \"semantic-ui-react\";\nimport store from \"./Store\";\n\ntype Props = {\n  track: Track;\n};\n\nconst TrackSettings = ({ track }: Props) => {\n  const color = store.getTrackColor(track.id);\n\n  return (\n    <Segment\n      style={{\n        borderTop: `2px solid ${color}`,\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n      }}\n    >\n      <List horizontal>\n        <List.Item>\n          <p>{track.name}</p>\n        </List.Item>\n        <List.Item>\n          <Input\n            label=\"Offset in seconds\"\n            labelPosition=\"left corner\"\n            type=\"number\"\n            val={`${store.tracksById[track.id].timeOffset / 1000}`}\n            onChange={(e) => {\n              store.tracksById[track.id].timeOffset = +e.target.value * 1000;\n            }}\n          ></Input>\n        </List.Item>\n        <List.Item>\n          <Button icon negative onClick={() => store.removeTrack(track.id)}>\n            <Icon name=\"trash\" />\n          </Button>\n        </List.Item>\n      </List>\n    </Segment>\n  );\n};\n\nexport default observer(TrackSettings);\n","import { observer } from \"mobx-react\";\nimport React from \"react\";\nimport { Map, TileLayer } from \"react-leaflet\";\nimport { Slider } from \"react-semantic-ui-range\";\nimport { Segment, Button } from \"semantic-ui-react\";\nimport AddTrack from \"./AddTrack\";\nimport \"./App.css\";\nimport store from \"./Store\";\nimport Track from \"./Track\";\nimport TrackSettings from \"./TrackSettings\";\n\nfunction App() {\n  return (\n    <div\n      className=\"App\"\n      style={{\n        display: \"flex\",\n        justifyContent: \"center\",\n        alignItems: \"center\",\n      }}\n    >\n      <div\n        style={{\n          position: \"absolute\",\n          top: 0,\n          right: 0,\n          zIndex: 1000,\n          maxHeight: \"calc(100vw - 100px)\",\n          overflow: \"auto\",\n        }}\n      >\n        <Segment>\n          {store.tracks.map((track) => (\n            <TrackSettings key={track.id} track={track} />\n          ))}\n          <AddTrack />\n        </Segment>\n      </div>\n      {store.tracks.length && (\n        <div\n          style={{\n            position: \"absolute\",\n            bottom: 0,\n            right: 0,\n            left: 0,\n            zIndex: 1000,\n          }}\n        >\n          <Segment style={{ display: \"flex\", alignItems: \"center\" }}>\n            <Button\n              onClick={() => {\n                store.autoIncrement = !store.autoIncrement;\n              }}\n              basic\n            >\n              {store.autoIncrement ? \"Stop\" : \"Play\"}\n            </Button>\n            <div style={{ flexGrow: 1 }}>\n              <Slider\n                value={store.currentTime}\n                settings={{\n                  min: 0,\n                  max: store.maxTime,\n                  step: 1,\n                  onChange: (value: number) => {\n                    if (Math.abs(value - store.currentTime) > 1000 * 60)\n                      store.autoIncrement = false;\n                    store.currentTime = value;\n                  },\n                }}\n              />\n            </div>\n          </Segment>\n        </div>\n      )}\n      <Map center={[49.75618698634207, 13.303053053095937]} zoom={15}>\n        <TileLayer\n          attribution='&amp;copy <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n          url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\n        />\n        {store.tracks.map((track, i) => (\n          <Track track={track} index={i} />\n        ))}\n      </Map>\n    </div>\n  );\n}\n\nexport default observer(App);\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}